for (i in 1:L){
for (j in 1:L){
z[i,j] <- ratios[count];
count <- count + 1;
}
}
op <- par(bg = "white")
persp(x, y, z, col = "lightblue")
library(lattice)
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(5-3, 4-3, 4-4, 2-2) + .1) # c(bottom,left,top,right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
round(res, 3);
op <- par(bg = "white")
persp(x, y, z, col = "lightblue")
library(lattice)
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(5-3, 4-3, 4-4, 2-2) + .1) # c(bottom,left,top,right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
getwd()
library(lattice)
xlabel     <- "alpha"
ylabel     <- "eta"
zlabel     <- "Estimate of B(h)"
# 1
rdata.file     <- "~/workspace/tm/data/fg_synth_cfg11.RData"
plot.file      <- "~/workspace/tm/data/fg_synth_cfg11.eps"
load(rdata.file)
x <- seq(start, end, by=interval); # e.g. (0.4, 12, 0.4)
y <- x;
L <- length(x);
z <- array(0, dim=c(L, L));
count <- 1;
for (i in 1:L){
for (j in 1:L){
z[i,j] <- ratios[count];
count <- count + 1;
}
}
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(5-3, 4-3, 4-4, 2-2) + .1) # c(bottom,left,top,right)
persp(x, y, z, col = "lightblue")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(5-4.5, 4-3, 4-4, 2-2) + .1) # c(bottom,left,top,right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
round(res, 3);
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(5-4.5, 4, 4-4, 2-2) + .1) # c(bottom,left,top,right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
round(res, 3);
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(5-3, 4, 4-4, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
round(res, 3);
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
round(res, 3);
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = expression(alpha), ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
round(res, 3);
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = expression(\alpha), ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = expression(pi), ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = expression('alpha'), ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.5) -> res
par(op)
dev.off()
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.35, cex.lab = 1.5) -> res
par(op)
dev.off()
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.25, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.35, cex.lab = 1.5) -> res
par(op)
dev.off()
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.5, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.35, cex.lab = 1.5) -> res
par(op)
dev.off()
round(res, 3);
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.5, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.35) -> res
par(op)
dev.off()
round(res, 3);
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.5, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5) -> res
par(op)
dev.off()
round(res, 3);
eps.bh.surface <- function(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.file){
library(lattice)
x <- seq(start, end, by=interval); # e.g. (0.4, 12, 0.4)
y <- x;
L <- length(x);
z <- array(0, dim=c(L, L));
count <- 1;
for (i in 1:L){
for (j in 1:L){
z[i,j] <- ratios[count];
count <- count + 1;
}
}
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.5, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5) -> res
par(op)
dev.off()
round(res, 3);
}
xlabel     <- "alpha"
ylabel     <- "eta"
zlabel     <- "Estimate of B(h)"
# 1
rdata.file     <- "~/workspace/tm/data/fg_synth_cfg11.RData"
plot.file      <- "~/workspace/tm/data/fg_synth_cfg11.eps"
load(rdata.file)
eps.bh.surface(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.file)
eps.bh.surface <- function(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.file){
library(lattice)
x <- seq(start, end, by=interval); # e.g. (0.4, 12, 0.4)
y <- x;
L <- length(x);
z <- array(0, dim=c(L, L));
count <- 1;
for (i in 1:L){
for (j in 1:L){
z[i,j] <- ratios[count];
count <- count + 1;
}
}
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.file, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.5, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.35) -> res
par(op)
dev.off()
round(res, 3);
}
eps.bh.surface(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.file)
eps.bh.surface <- function(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.title, plot.file){
library(lattice)
x <- seq(start, end, by=interval); # e.g. (0.4, 12, 0.4)
y <- x;
L <- length(x);
z <- array(0, dim=c(L, L));
count <- 1;
for (i in 1:L){
for (j in 1:L){
z[i,j] <- ratios[count];
count <- count + 1;
}
}
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.title, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.5, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.35) -> res
par(op)
dev.off()
round(res, 3);
}
eps.bh.surface(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.title, plot.file)
plot.title     <- "true h = (3, 3)"
eps.bh.surface(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.title, plot.file)
eps.bh.surface <- function(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.title, plot.file){
library(lattice)
x <- seq(start, end, by=interval); # e.g. (0.4, 12, 0.4)
y <- x;
L <- length(x);
z <- array(0, dim=c(L, L));
count <- 1;
for (i in 1:L){
for (j in 1:L){
z[i,j] <- ratios[count];
count <- count + 1;
}
}
op <- par(bg = "white")
trellis.device(postscript, file=plot.file,
height=5.5, width=6.5, horiz=F,
title=plot.title, onefile=T)
par(mar=c(4-3, 4, 4-3, 2-2) + .1) # c(bottom, left, top, right)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.3, ticktype = "detailed",
xlab = xlabel, ylab = ylabel, zlab = zlabel,
cex = 1.5, cex.lab = 1.35) -> res
par(op)
dev.off()
round(res, 3);
}
rdata.file     <- "~/workspace/tm/data/fg_synth_cfg11.RData"
plot.file      <- "~/workspace/tm/data/fg_synth_cfg11.eps"
plot.title     <- "true h = (3, 3)"
load(rdata.file)
eps.bh.surface(ratios, start, end, interval, xlabel, ylabel, zlabel, plot.title, plot.file)
# Init file names
rdata.file <- "/home/clintpg/results/fg_cg_ae33.RData"
log.marginal.posterior.plot <- "/home/clintpg/results/fg_cg_ae33_lmp.eps"
theta.acf.plot <- "/home/clintpg/results/fg_cg_ae33_theta.eps"
beta.acf.plot <- "/home/clintpg/results/fg_cg_ae33_beta.eps"
# Loads the saved data
load(rdata.file)
?postscript
## Loads packages
library(ldahp);
## Initialize variables
set.seed(1983)
K              <- 2 # the number of topics
D              <- 100 # the total number of documents to be generated
V              <- 20 # the vocabulary size
max.iter       <- 5000 # the maximum number of Gibbs iterations
burn.in        <- 1000
spacing        <- 40
lambda.hat     <- 80
gen.eta        <- 3
gen.alpha.v    <- c(3, 3)
gen.eta.v      <- array(gen.eta, c(1, V));                   # symmetric Dirichlet
store.Dir      <- 1                                    # store the \theta and \beta Dirichlet samples ?
## Generates the synthetic beta.m
beta.m         <- matrix(1e-2, nrow=K, ncol=V)
beta.m[1, ]    <- rdirichlet(1, gen.eta.v);
beta.m[2, ]    <- rdirichlet(1, gen.eta.v);
## Generates documents with a given beta.m
ds             <- generate_docs_fixed_beta(D, lambda.hat, gen.alpha.v, beta.m);
## The full Gibbs sampling
ptm            <- proc.time();
fg.mdl         <- lda_full_c2(K, V, ds$wid, ds$doc.N, gen.alpha.v, gen.eta, max.iter, burn.in, spacing, store.Dir);
ptm            <- proc.time() - ptm;
cat("execution time = ", ptm[3], "\n");
## The collapsed Gibbs sampling
ptm            <- proc.time();
cg.mdl         <- lda_collapsed_gibbs_c(K, V, ds$wid, ds$doc.N, gen.alpha.v, gen.eta, max.iter, burn.in, spacing, store.Dir);
ptm            <- proc.time() - ptm;
cat("execution time = ", ptm[3], "\n");
library(ldahp)
?cex
?plot
?qqplot
?runif
u <- runif(100)
?hist
?abline
abline(0,1,cex=2)
rm(list=ls());
# load the necessary libraries
library(ldahp);
options(digits=2)
set.seed(1983);
## h = (eta, alpha) = (3, 7)
rdata.file     <- "fg_ea37.RData"
gen.eta        <- 3 # symmetric Dirichlet
gen.alpha      <- 7 # symmetric Dirichlet
K              <- 2 # the number of topics
D              <- 1000 # the total number of documents to be generated
V              <- 20 # the vocabulary size
start          <- 0.2
end            <- 12
interval       <- 0.2
max.iter       <- 61000 # the maximum number of Gibbs iterations
burn.in        <- 1000
spacing        <- 50
lambda.hat     <- 80
store.Dir      <- 1
gen.alpha.v    <- array(gen.alpha, c(K, 1));
gen.eta.v      <- array(gen.eta, c(1, V));
alphas         <- gen_meshgrid(start, end, interval)   # generate alpha grid (2-D)
alphas
## h = (eta, alpha) = (3, 7)
rdata.file     <- "fg_ea37.RData"
gen.eta        <- 3 # symmetric Dirichlet
gen.alpha      <- 7 # symmetric Dirichlet
base.alpha.idx <- 2055
alphas[,base.alpha.idx]
#####################################################################################################################
## Testing the LDA library in R
#####################################################################################################################
library(lda);
setwd('~/workspace/whales_tires')
set.seed(1983);
num.topics  <- 2;
itr         <- 2000; ## Num iterations
av          <- 1;
ev          <- 1;
bp          <- 1600;
documents   <- read.documents(filename = "whales-tires.ldac");
vocab       <- read.vocab(filename = "whales-tires.ldac.vocab")
result      <- lda.collapsed.gibbs.sampler(documents, num.topics, vocab, itr, alpha=av, eta=ev, burnin=bp, trace=2L);
top.topic.words(result$topics, 20, by.score=TRUE);
setwd('~/workspace/tm/datasets/whales-tires')
set.seed(1983);
documents   <- read.documents(filename = "whales-tires.ldac");
vocab       <- read.vocab(filename = "whales-tires.ldac.vocab")
##############################################################################################
## This script is to test the hyperparameter estimation algorithm
## using the likelihood ratios on a real dataset. We used the documents
## extracted from the Wikipedia for this experiment
##
##############################################################################################
# Sets the working dir
setwd('~/workspace/tm/datasets/whales-tires')
set.seed(1983)
options(digits=2)
library(MCMCpack)
library(ldahp)
## Loads Wikipedia data (from Categories: Whales and Tires)
vocab <- readLines('whales-tires.ldac.vocab');
documents <- read_docs('whales-tires.ldac');
ds <- vectorize_docs(documents)
doc.N <- calc_doc_lengths(documents)
## Initialize variables
V              <- length(vocab)
K              <- 2                                 # the number of topics
alpha.v        <- c(1, 1)              # symmetric Dirichlet
eta            <- 1
max.iter       <- 1000                              # the maximum number of Gibbs iterations
burn.in        <- 800
spacing        <- 1
store.Dir      <- 1
## The Gibbs sampling
## Based on the C++ implementation
## Always append the vocabulary ids by 1, because LDA-C consider vocabulary starts at 0
## The full Gibbs sampling
ptm            <- proc.time();
fg.mdl         <- lda_full_c2(K, V, ds$wid+1, doc.N, alpha.v, eta, max.iter, burn.in, spacing, store.Dir);
ptm            <- proc.time() - ptm;
cat("execution time = ", ptm[3], "\n");
## The collapsed Gibbs sampling
ptm            <- proc.time();
cg.mdl         <- lda_collapsed_gibbs_c(K, V, ds$wid+1, doc.N, alpha.v, eta, max.iter, burn.in, spacing, store.Dir);
ptm            <- proc.time() - ptm;
cat("execution time = ", ptm[3], "\n");
dim(result$topics)
# Sets the working dir
setwd('~/workspace/tm/datasets/whales-tires')
set.seed(1983)
options(digits=2)
library(MCMCpack)
library(ldahp)
## Loads Wikipedia data (from Categories: Whales and Tires)
vocab <- readLines('whales-tires.ldac.vocab');
documents <- read_docs('whales-tires.ldac');
ds <- vectorize_docs(documents)
doc.N <- calc_doc_lengths(documents)
## Initialize variables
V              <- length(vocab)
K              <- 2                                 # the number of topics
alpha.v        <- c(1, 1)              # symmetric Dirichlet
eta            <- 1
max.iter       <- 1000                              # the maximum number of Gibbs iterations
burn.in        <- 800
spacing        <- 1
store.Dir      <- 1
## The Gibbs sampling
## Based on the C++ implementation
## Always append the vocabulary ids by 1, because LDA-C consider vocabulary starts at 0
## The full Gibbs sampling
ptm            <- proc.time();
fg.mdl         <- lda_fgs(K, V, ds$wid+1, doc.N, alpha.v, eta, max.iter, burn.in, spacing, store.Dir);
ptm            <- proc.time() - ptm;
cat("execution time = ", ptm[3], "\n");
# Sets the working dir
setwd('~/workspace/tm/datasets/whales-tires')
set.seed(1983)
options(digits=2)
library(MCMCpack)
library(ldahp)
ptm            <- proc.time();
fg.mdl         <- lda_fgs(K, V, ds$wid+1, doc.N, alpha.v, eta, max.iter, burn.in, spacing, store.Dir);
ptm            <- proc.time() - ptm;
cat("execution time = ", ptm[3], "\n");
